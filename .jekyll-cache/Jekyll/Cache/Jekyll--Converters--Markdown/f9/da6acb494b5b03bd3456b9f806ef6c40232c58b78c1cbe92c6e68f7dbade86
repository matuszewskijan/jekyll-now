I"€<p>Given the requirements that client submit himself to a queue that should return results of some heavy background task. The server should be able to skip clients that already left the queue before their input were processed.</p>

<p>It doesn‚Äôt sound very complicated at the first glance, but Googling for any solution doesn‚Äôt return any resources except implementing queuing libraries like RabbitMQ. Our goal were to make the solution relatively straightforward and doesn‚Äôt increase complexity of the app by additional library.</p>

<p>The application were already using <code class="language-plaintext highlighter-rouge">Sidekiq</code> as background job processor and <code class="language-plaintext highlighter-rouge">Redis</code> as queue store. Given that I‚Äôve tried to see what we could do using only these.</p>

<p>While lurking through Redis documentation I‚Äôve found it‚Äôs <a href="https://redis.io/commands/TTL">TTL(time-to-live)</a> functionality:</p>
<pre><code class="language-redis">redis&gt; SET mykey "Hello"
"OK"
redis&gt; EXPIRE mykey 10
(integer) 1
redis&gt; TTL mykey
(integer) 10
redis&gt;
</code></pre>

<p>It gave me the idea ‚Äúif Sidekiq job is pushed to Redis queue under specific key maybe we could set TTL on this key?‚Äù</p>

<p>How do we know the key that Sidekiq used? It‚Äôs simple, when you use <code class="language-plaintext highlighter-rouge">perform_async</code> on any Sidekiq worker you will get the key as the result(it‚Äôs named JID in sidekiq(add link)):</p>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mo">001</span><span class="p">:</span><span class="mi">0</span><span class="o">&gt;</span> <span class="n">job_id</span> <span class="o">=</span> <span class="no">SomeSidekiqWorker</span><span class="p">.</span><span class="nf">perform_async</span>
<span class="o">=&gt;</span> <span class="s2">"fc3f44f792492883d843fac4"</span>
</code></pre></div></div>

<p>Next step will be to set the expiration time for our JID:</p>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">redis</span> <span class="o">=</span> <span class="no">Redis</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="c1"># Chances are that you already have Redis instance defined</span>
<span class="n">redis</span><span class="p">.</span><span class="nf">setex</span><span class="p">(</span><span class="n">job_id</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</code></pre></div></div>

<p>Now if the Sidekiq worker won‚Äôt start in 2 seconds it will be completely removed from the queue. I‚Äôve mentioned that we do want the job to be performed only as long as the is present on the page. The last step we need to add is some kind of polling that will reset TTL.</p>

<p>For this <a href="https://guides.rubyonrails.org/action_cable_overview.html#example-1-user-appearances">ActionCable</a> might be ideal.</p>

<p><a href="https://github.com/GalacticPlastic/ironhack/wiki/Active-Jobs%2C-Sidekiq%2C-Redis#job-id">Check provider job ID</a> maybe it‚Äôs possible to do it with ActiveJob?</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>job_id = Sidekiq::Client.push(queue: '', class: '', args: [])
redis.setex(job_id, 2)
redis.llen('queue:default')
</code></pre></div></div>

<p>[https://picsum.photos/]</p>
:ET